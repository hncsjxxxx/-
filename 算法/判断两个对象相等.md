alert([]==[]);    // false </br>
alert([]===[]);   // false</br>
NaN === NaN;        // false</br>
[阿里大佬的文章](https://github.com/mqyqingfeng/Blog/issues/41)
# 前言
虽然标题写的是如何判断两个对象相等，但本篇我们不仅仅判断两个对象相等，实际上，我们要做到的是如何判断两个参数相等，而这必然会涉及到多种类型的判断。

# 相等
什么是相等？在《JavaScript专题之去重》中，我们认为只要 === 的结果为 true，两者就相等，然而今天我们重新定义相等：</br>

我们认为：

* NaN 和 NaN 是相等
* [1] 和 [1] 是相等
* {value: 1} 和 {value: 1} 是相等
不仅仅是这些长得一样的，还有

* 1 和 new Number(1) 是相等
* 'Curly' 和 new String('Curly') 是相等
* true 和 new Boolean(true) 是相等
更复杂的我们会在接下来的内容中看到。

# 目标
我们的目标是写一个 eq 函数用来判断两个参数是否相等，使用效果如下：
```javascript
function eq(a, b) { ... }

var a = [1];
var b = [1];
console.log(eq(a, b)) // true
```

在写这个看似很简单的函数之前，我们首先了解在一些简单的情况下是如何判断的？</br>

## +0和-0
如果 a === b 的结果为 true， 那么 a 和 b 就是相等的吗？一般情况下，当然是这样的，但是有一个特殊的例子，就是 +0 和 -0。JavaScript “处心积虑”的想抹平两者的差异：
```javascript
// 表现1
console.log(+0 === -0); // true

// 表现2
(-0).toString() // '0'
(+0).toString() // '0'

// 表现3
-0 < +0 // false
+0 < -0 // false
```
即便如此，两者依然是不同的：
```javascript
1 / +0 // Infinity
1 / -0 // -Infinity

1 / +0 === 1 / -0 // false
```
也许你会好奇为什么要有 +0 和 -0 呢？</br>
这是因为 JavaScript 采用了IEEE_754 浮点数表示法(几乎所有现代编程语言所采用)，这是一种二进制表示法，按照这个标准，最高位是符号位(0 代表正，1 代表负)，剩下的用于表示大小。而对于零这个边界值 ，1000(-0) 和 0000(0)都是表示 0 ，这才有了正负零的区别。</br>
也许你会好奇什么时候会产生 -0 呢？</br>
```javascript
Math.round(-0.1) // -0
```
那么我们又该如何在 === 结果为 true 的时候，区别 0 和 -0 得出正确的结果呢？我们可以这样做：</br>
```javascript
function eq(a, b){
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    return false;
}

console.log(eq(0, 0)) // true
console.log(eq(0, -0)) // false
```
## NaN
在本篇，我们认为 NaN 和 NaN 是相等的，那又该如何判断出 NaN 呢？</br>
```javascript
console.log(NaN === NaN); // false
```
利用 NaN 不等于自身的特性，我们可以区别出 NaN，那么这个 eq 函数又该怎么写呢？

```javascript
function eq(a, b) {
    if (a !== a) return b !== b;
}

console.log(eq(NaN, NaN)); // true
```
## eq函数
现在，我们已经可以去写 eq 函数的第一版了。
```javascript
// eq 第一版
// 用来过滤掉简单的类型比较，复杂的对象使用 deepEq 函数进行处理
function eq(a, b) {

    // === 结果为 true 的区别出 +0 和 -0
    if (a === b) return a !== 0 || 1 / a === 1 / b;

    // typeof null 的结果为 object ，这里做判断，是为了让有 null 的情况尽早退出函数
    if (a == null || b == null) return false;

    // 判断 NaN
    if (a !== a) return b !== b;

    // 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;

    // 更复杂的对象使用 deepEq 函数进行深度比较
    return deepEq(a, b);
};
```
也许你会好奇是不是少了一个 typeof b !== function?</br>
试想如果我们添加上了这句，当 a 是基本类型，而 b 是函数的时候，就会进入 deepEq 函数，而去掉这一句，就会进入直接进入 false，实际上 基本类型和函数肯定是不会相等的，所以这样做代码又少，又可以让一种情况更早退出。



